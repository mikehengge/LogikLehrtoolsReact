package lehrtools.formula.parser.parsing;

import java.util.LinkedList;

import lehrtools.formula.Formula;
import lehrtools.formula.Not;
import lehrtools.formula.Or;
import lehrtools.formula.And;
import lehrtools.formula.Falsum;
import lehrtools.formula.Variable;
import lehrtools.formula.Verum;
import lehrtools.formula.parser.lexing.Token;
/**
 * This Class generates the Formula out of the token list provided by
 * the Lexer class. 
 * The method parse(...) will start the generation of the Formula.
 * As a result a Formula representing the given input will be returned or a ParserException 
 * will be raised.
 * The Formula is generated based on the grammar that define the expression, 
 * cycling through each rule in a recursive manner.
 *
 */
public class Parser_Gen {
	
	  /**
	   * List of tokens representing the given input.
	   */
	  private LinkedList<Token> tokens;
	  /**
	   * next token to be processed.
	   */
	  private Token lookahead;
	  
	 /**
	  *  <p>
	  *  Starts the generation of the Formula corresponding to the given 
	  *  input string.
	  *  Should the input not be a valid Formula then an ParserException is raised.
	  *  </p>
	  * @param tokens : 
	  * 				List of tokens generated by the Lexer_Formula class.
	  * @return : 
	  * 			An instance of Formula representing the given input.
	  */
	@SuppressWarnings("unchecked")
	public Formula parse(LinkedList<Token> tokens)
	  {
	    this.tokens = (LinkedList<Token>) tokens.clone();
	    lookahead = this.tokens.getFirst();
	    
	    Formula formula = expression();

	    if (lookahead.token != Token.EPSILON)
	      throw new ParserException("Unexpected symbol " +  lookahead.sequence + " found");
	    
	    return formula;
	  }
	/**
	 * Method used to retrieve the next token to be processed by the parser,
	 * if the end of the list is reached a EPSILON token will be set, to signal that
	 * the end. 
	 */
	private void nextToken()
	  {
	    tokens.pop();
	    // at the end of input we return an epsilon token
	    if (tokens.isEmpty())
	      lookahead = new Token(Token.EPSILON, "");
	    else
	      lookahead = tokens.getFirst();
	  }
	  
	  
	  /**
	   * This method applies the rule argument -&gt; VARIABLE| OPEN_BRACKet expression OPEN_BRACKET
	   * Creates an Variable instance if the lookahead.token of 
	   * the type VARIABLE. The Variable is named after
	   * the sequence stored in the token.
	   * If the lookahead.token is of the type OPEN_BRACKET
	   * then a new expression is parsed, i.e. ( expression )
	   * Should the lookahead.token not match any of the above
	   * mentioned types, then an ParserEsception is raised.
	   *  
	   * @return :
	   * 			An instance of Formula representing the part of the input being parsed.
	   */
	  private Formula argument()
	  {
		  // Rule argument -> VARIABLE
		  if(lookahead.token == Token.VARIABLE)
		  {
			  switch(lookahead.sequence)
			  {
			  case "true": Formula v = Verum.mk();
			  			   nextToken();
			  			   return v;
				  			
			  case "false": Formula f = Falsum.mk();
			  				nextToken();
			  				return f;
			  default: Variable var = new Variable(lookahead.sequence);
			  		   nextToken();
			  		   return var;
			  }
			  
		  }
		  //Rule argument -> OPEN_BRACKET expression CLOSED_BRACKET
		  if(lookahead.token == Token.OPEN_BRACKET)
		  {
			  nextToken();
			  Formula formula = expression();
			  if(lookahead.token != Token.CLOSE_BRACKET)
				  throw new ParserException("Closing brackets expected instead " , lookahead);
			  nextToken();
			  return formula;
				  
		  }
		  
		  if (lookahead.token == Token.EPSILON)
			    throw new ParserException("Unexpected end of input");
		  else
			    throw new ParserException("Unexpected symbol %s found", lookahead);
		  
	  }
	  
	  /**
	   * This method applies the rule factor -&gt; NOT argument | argument.
	   * If the next token is of Type NOT , then a an instance of Not is created, 
	   * otherwise the calculations are passed onto the method argument.
	   * 
	   * @return :
	   * 			An instance of Formula representing the part of the input being parsed.
	   */
	  private Formula factor()
	  {
		  //Rule : factor -> NOT argument
		  if(lookahead.token == Token.NOT)
		  {
			  nextToken();
			  Formula formula = argument();
			  return new Not(formula);
		  }
		  //Rule : factor -> argument
		  return argument();
	  }
	  /**
	   * This method applies the rule and_op -&gt; AND factor and_op | EPSILON
	   * If lookahead.token is of type AND, then expression_1 becomes the first operand
	   * for the binary operator And, and the second operand is 
	   * calculated using the method factor().
	   * If the lookahead.token differs from AND then expression_1 is returned.
	   * @param expression_1 :
	   * 						Formula needed in case a binary And operation is parsed.
	   * @return
	   * 			An instance of Formula representing the part of the input being parsed.
	   */
	  private Formula and_op(Formula expression_1)
	  {
		  //Rule : and_op -> AND Factor and_op
		  if(lookahead.token == Token.AND)
		  {
			  
			  nextToken();
			  Formula expression = new And(expression_1, factor());
			  
			  return and_op(expression);
		  }
		  
		  //Rule and_op -> Epsilon
		  return expression_1;
	  }
	  /**
	   * This method applies the rule term -&gt; factor and_op
	   * First the method factor() is applied to the part of the
	   * input that hasn't been processed. 
	   * To the remainder of the input and_op(formula) is applied
	   * @return :
	   * 		An instance of Formula representing the part of the input being parsed.
	   */
	  private Formula term()
	  {
		  //Rule : term -> factor and_op
		  Formula formula = factor();
		  return and_op(formula);
	  }
	  /**
	   * This method applies the Rule or_op -&gt; OR term or_op | EPSILON.
	   * if the lookahead.token equals OR then the expression_1 becomes the first operand
	   * for the binary operator OR, and the second operand is 
	   * calculated using the method term().
	   * If the lookahead.token differs from OR then expression_1 is returned.
	   * @param expression_1 :
	   * 				Formula needed in case a binary Or operation is parsed.
	   * @return :
	   * 			An instance of Formula representing the part of the input being parsed.
	   */
	  private Formula or_op(Formula expression_1)
	  {
		  //Rule : or_op -> OR term or_op
		  if(lookahead.token == Token.OR)
		  {
			  nextToken();
			  Formula proposition = new Or(expression_1,term());
			  return or_op(proposition);
			  
		  }
		  //Rule : or_op -> Epsilon
		  return expression_1;
	  }
	  /**
	   * This method starts the calculation of parsing a new Formula
	   * from the given input string.
	   * It also process the expression in that is part of the rule
	   * argument -&gt; OPEN_BRACKET expression CLOSED_BRACKET
	   * 
	   * @return :
	   * 			An instance of Formula representing the part of the input being parsed.
	   */
	  private Formula expression()
	  {
		  //Rule : proposition -> term or_op
		  Formula term = term();
		  return or_op(term);
	  }

}
